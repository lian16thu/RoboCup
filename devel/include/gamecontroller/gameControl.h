// Generated by gencpp from file gamecontroller/gameControl.msg
// DO NOT EDIT!


#ifndef GAMECONTROLLER_MESSAGE_GAMECONTROL_H
#define GAMECONTROLLER_MESSAGE_GAMECONTROL_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace gamecontroller
{
template <class ContainerAllocator>
struct gameControl_
{
  typedef gameControl_<ContainerAllocator> Type;

  gameControl_()
    : gameType(0)
    , state(0)
    , firstHalf(0)
    , kickOffTeam(0)
    , secondaryState(0)
    , secondaryStateTeam(0)
    , secondaryStateInfo(0)
    , dropInTeam(0)
    , dropInTime(0)
    , secsRemaining(0)
    , secondaryTime(0)
    , score(0)
    , penaltyShot(0)
    , singleShots(0)
    , penalty(0)
    , secsTillUnpenalised(0)
    , yellowCardCount(0)
    , redCardCount(0)  {
    }
  gameControl_(const ContainerAllocator& _alloc)
    : gameType(0)
    , state(0)
    , firstHalf(0)
    , kickOffTeam(0)
    , secondaryState(0)
    , secondaryStateTeam(0)
    , secondaryStateInfo(0)
    , dropInTeam(0)
    , dropInTime(0)
    , secsRemaining(0)
    , secondaryTime(0)
    , score(0)
    , penaltyShot(0)
    , singleShots(0)
    , penalty(0)
    , secsTillUnpenalised(0)
    , yellowCardCount(0)
    , redCardCount(0)  {
  (void)_alloc;
    }



   typedef uint8_t _gameType_type;
  _gameType_type gameType;

   typedef uint8_t _state_type;
  _state_type state;

   typedef uint8_t _firstHalf_type;
  _firstHalf_type firstHalf;

   typedef uint8_t _kickOffTeam_type;
  _kickOffTeam_type kickOffTeam;

   typedef uint8_t _secondaryState_type;
  _secondaryState_type secondaryState;

   typedef uint8_t _secondaryStateTeam_type;
  _secondaryStateTeam_type secondaryStateTeam;

   typedef uint8_t _secondaryStateInfo_type;
  _secondaryStateInfo_type secondaryStateInfo;

   typedef uint8_t _dropInTeam_type;
  _dropInTeam_type dropInTeam;

   typedef uint16_t _dropInTime_type;
  _dropInTime_type dropInTime;

   typedef uint16_t _secsRemaining_type;
  _secsRemaining_type secsRemaining;

   typedef uint16_t _secondaryTime_type;
  _secondaryTime_type secondaryTime;

   typedef uint8_t _score_type;
  _score_type score;

   typedef uint8_t _penaltyShot_type;
  _penaltyShot_type penaltyShot;

   typedef uint16_t _singleShots_type;
  _singleShots_type singleShots;

   typedef uint8_t _penalty_type;
  _penalty_type penalty;

   typedef uint8_t _secsTillUnpenalised_type;
  _secsTillUnpenalised_type secsTillUnpenalised;

   typedef uint8_t _yellowCardCount_type;
  _yellowCardCount_type yellowCardCount;

   typedef uint8_t _redCardCount_type;
  _redCardCount_type redCardCount;





  typedef boost::shared_ptr< ::gamecontroller::gameControl_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::gamecontroller::gameControl_<ContainerAllocator> const> ConstPtr;

}; // struct gameControl_

typedef ::gamecontroller::gameControl_<std::allocator<void> > gameControl;

typedef boost::shared_ptr< ::gamecontroller::gameControl > gameControlPtr;
typedef boost::shared_ptr< ::gamecontroller::gameControl const> gameControlConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::gamecontroller::gameControl_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::gamecontroller::gameControl_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace gamecontroller

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'gamecontroller': ['/home/lian/robot_ws/src/gamecontroller/msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::gamecontroller::gameControl_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::gamecontroller::gameControl_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::gamecontroller::gameControl_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::gamecontroller::gameControl_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gamecontroller::gameControl_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gamecontroller::gameControl_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::gamecontroller::gameControl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8187bc9e4bf6fa1896498e321b213f47";
  }

  static const char* value(const ::gamecontroller::gameControl_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8187bc9e4bf6fa18ULL;
  static const uint64_t static_value2 = 0x96498e321b213f47ULL;
};

template<class ContainerAllocator>
struct DataType< ::gamecontroller::gameControl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "gamecontroller/gameControl";
  }

  static const char* value(const ::gamecontroller::gameControl_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::gamecontroller::gameControl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint8 gameType\n\
uint8 state\n\
uint8 firstHalf\n\
uint8 kickOffTeam\n\
uint8 secondaryState\n\
uint8 secondaryStateTeam\n\
uint8 secondaryStateInfo\n\
uint8 dropInTeam\n\
uint16 dropInTime\n\
uint16 secsRemaining\n\
uint16 secondaryTime\n\
\n\
uint8 score\n\
uint8 penaltyShot\n\
uint16 singleShots\n\
\n\
uint8 penalty\n\
uint8 secsTillUnpenalised\n\
uint8 yellowCardCount\n\
uint8 redCardCount\n\
";
  }

  static const char* value(const ::gamecontroller::gameControl_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::gamecontroller::gameControl_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.gameType);
      stream.next(m.state);
      stream.next(m.firstHalf);
      stream.next(m.kickOffTeam);
      stream.next(m.secondaryState);
      stream.next(m.secondaryStateTeam);
      stream.next(m.secondaryStateInfo);
      stream.next(m.dropInTeam);
      stream.next(m.dropInTime);
      stream.next(m.secsRemaining);
      stream.next(m.secondaryTime);
      stream.next(m.score);
      stream.next(m.penaltyShot);
      stream.next(m.singleShots);
      stream.next(m.penalty);
      stream.next(m.secsTillUnpenalised);
      stream.next(m.yellowCardCount);
      stream.next(m.redCardCount);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct gameControl_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::gamecontroller::gameControl_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::gamecontroller::gameControl_<ContainerAllocator>& v)
  {
    s << indent << "gameType: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gameType);
    s << indent << "state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state);
    s << indent << "firstHalf: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.firstHalf);
    s << indent << "kickOffTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.kickOffTeam);
    s << indent << "secondaryState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondaryState);
    s << indent << "secondaryStateTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondaryStateTeam);
    s << indent << "secondaryStateInfo: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondaryStateInfo);
    s << indent << "dropInTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dropInTeam);
    s << indent << "dropInTime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.dropInTime);
    s << indent << "secsRemaining: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secsRemaining);
    s << indent << "secondaryTime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secondaryTime);
    s << indent << "score: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.score);
    s << indent << "penaltyShot: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.penaltyShot);
    s << indent << "singleShots: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.singleShots);
    s << indent << "penalty: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.penalty);
    s << indent << "secsTillUnpenalised: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secsTillUnpenalised);
    s << indent << "yellowCardCount: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.yellowCardCount);
    s << indent << "redCardCount: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.redCardCount);
  }
};

} // namespace message_operations
} // namespace ros

#endif // GAMECONTROLLER_MESSAGE_GAMECONTROL_H
